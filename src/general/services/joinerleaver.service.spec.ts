/* eslint-disable @typescript-eslint/no-explicit-any */
import { Test, TestingModule } from '@nestjs/testing';
import { Logger } from '@nestjs/common';
import { TestBootstrapper } from '../../test.bootstrapper';
import { getRepositoryToken } from '@mikro-orm/nestjs';
import { JoinerLeaverService } from './joinerleaver.service';
import { JoinerLeaverEntity } from '../../database/entities/joiner.leaver.entity';
import { GuildMember } from 'discord.js';
import { generateDateInPast } from '../../helpers';
import { JoinerLeaverStatisticsEntity } from '../../database/entities/joiner.leaver.statistics.entity';

describe('JoinerLeaverService', () => {
  let joinerLeaverService: JoinerLeaverService;

  let mockChannel: any;
  let mockStatusMessage: any;
  let mockGuildMember = TestBootstrapper.getMockDiscordUser();

  let mockJoinerLeaverRepository: any;
  let mockJoinerLeaverStatisticsRepository: any;

  const createMockJoinerLeaverEntity = (): Partial<JoinerLeaverEntity> => ({
    discordId: mockGuildMember.id,
    discordNickname: mockGuildMember.displayName,
    joinDate: null,
    leaveDate: null,
    rejoinCount: 0,
    createdAt: new Date(),
    updatedAt: new Date(),
  });

  const mockJoinerLeaverStatisticsEntity: any = {
    joiners: 10,
    leavers: 5,
    rejoiners: 2,
    earlyLeavers: 1,
    avgTimeToLeave: '1d 13h 37m',
    // Assumed / base entity autogenerated
    createdAt: new Date(),
    updatedAt: new Date(),
  } as JoinerLeaverStatisticsEntity;

  beforeEach(async () => {
    mockJoinerLeaverRepository = TestBootstrapper.getMockRepositoryInjected(createMockJoinerLeaverEntity());
    mockJoinerLeaverStatisticsRepository = TestBootstrapper.getMockRepositoryInjected(mockJoinerLeaverStatisticsEntity);

    const module: TestingModule = await Test.createTestingModule({
      providers: [
        JoinerLeaverService,
        {
          provide: getRepositoryToken(JoinerLeaverEntity),
          useValue: mockJoinerLeaverRepository,
        },
        {
          provide: getRepositoryToken(JoinerLeaverStatisticsEntity),
          useValue: mockJoinerLeaverStatisticsRepository,
        },
        Logger,
      ],
    }).compile();

    joinerLeaverService = module.get<JoinerLeaverService>(JoinerLeaverService);
    mockGuildMember = TestBootstrapper.getMockDiscordUser();
    mockStatusMessage = TestBootstrapper.getMockDiscordMessage();
    mockChannel = TestBootstrapper.getMockDiscordTextChannel();
    mockChannel.send = jest.fn().mockResolvedValue(mockStatusMessage);

    jest.spyOn(joinerLeaverService['logger'], 'error');
    jest.spyOn(joinerLeaverService['logger'], 'warn');
    jest.spyOn(joinerLeaverService['logger'], 'log');
    jest.spyOn(joinerLeaverService['logger'], 'debug');
  });

  it('should be defined', () => {
    expect(joinerLeaverService).toBeDefined();
  });

  describe('recordJoiner', () => {
    beforeEach(() => {
      mockJoinerLeaverRepository.findOne = jest.fn().mockResolvedValue(null);
    });

    it('should record a new joiner', async () => {
      await joinerLeaverService.recordJoiner(mockGuildMember);

      expect(mockJoinerLeaverRepository.findOne).toHaveBeenCalledWith({ discordId: mockGuildMember.id });

      expect(mockJoinerLeaverRepository.getEntityManager().persistAndFlush).toHaveBeenCalledWith({
        discordId: mockGuildMember.id,
        discordNickname: mockGuildMember.displayName,
        joinDate: expect.any(Date),
        leaveDate: null,
        rejoinCount: 0,
        // Assumed / base entity autogenerated
        createdAt: expect.any(Date),
        updatedAt: expect.any(Date),
        id: undefined,
      });

      expect(joinerLeaverService['logger'].log).toHaveBeenCalledWith(`Recorded joiner ${mockGuildMember.user.tag} (${mockGuildMember.id})`);
    });

    it('should record a previous joiner', async () => {
      mockJoinerLeaverRepository.findOne = jest.fn().mockResolvedValue(createMockJoinerLeaverEntity());

      await joinerLeaverService.recordJoiner(mockGuildMember);

      expect(mockJoinerLeaverRepository.findOne).toHaveBeenCalledWith({ discordId: mockGuildMember.id });

      expect(mockJoinerLeaverRepository.getEntityManager().persistAndFlush).toHaveBeenCalledWith(expect.objectContaining({
        discordId: mockGuildMember.id,
        discordNickname: mockGuildMember.displayName,
        joinDate: expect.any(Date),
        leaveDate: null,
        rejoinCount: 1,
        // Assumed / base entity autogenerated
        createdAt: expect.any(Date),
        updatedAt: expect.any(Date),
      }));
    });

    it('should correctly increment a rejoiner', async () => {
      const rejoinedLeaver = {
        ...createMockJoinerLeaverEntity(),
        rejoinCount: 1,
      };

      mockJoinerLeaverRepository.findOne = jest.fn().mockResolvedValue(rejoinedLeaver);

      await joinerLeaverService.recordJoiner(mockGuildMember);

      expect(mockJoinerLeaverRepository.getEntityManager().persistAndFlush).toHaveBeenCalledWith(expect.objectContaining({
        discordId: mockGuildMember.id,
        discordNickname: mockGuildMember.displayName,
        joinDate: expect.any(Date),
        leaveDate: null,
        rejoinCount: 2,
        // Assumed / base entity autogenerated
        createdAt: expect.any(Date),
        updatedAt: expect.any(Date),
      }));
    });

    it('should do nothing if the member is a bot', async () => {
      const mockMember = {
        user: { bot: true },
      } as GuildMember;

      await joinerLeaverService.recordJoiner(mockMember);

      expect(mockJoinerLeaverRepository.findOne).not.toHaveBeenCalled();
      expect(mockJoinerLeaverRepository.getEntityManager().persistAndFlush).not.toHaveBeenCalled();
      expect(joinerLeaverService['logger'].log).not.toHaveBeenCalled();
    });
  });

  describe('recordLeaver', () => {
    beforeEach(() => {
      mockJoinerLeaverRepository.findOne = jest.fn().mockResolvedValue(createMockJoinerLeaverEntity());
    });

    it('should record a leaver', async () => {
      await joinerLeaverService.recordLeaver(mockGuildMember);

      expect(mockJoinerLeaverRepository.findOne).toHaveBeenCalledWith({ discordId: mockGuildMember.id });

      expect(mockJoinerLeaverRepository.getEntityManager().persistAndFlush).toHaveBeenCalledWith(
        expect.objectContaining({
          discordId: mockGuildMember.id,
          discordNickname: mockGuildMember.displayName,
          joinDate: null,
          leaveDate: expect.any(Date),
          rejoinCount: 0,
          createdAt: expect.any(Date),
          updatedAt: expect.any(Date),
        })
      );

      expect(joinerLeaverService['logger'].log).toHaveBeenCalledWith(`Recorded leaver ${mockGuildMember.user.tag} (${mockGuildMember.id})`);
    });
  });

  it('should error if a leaver is not found', async () => {
    mockJoinerLeaverRepository.findOne = jest.fn().mockResolvedValue(null);

    await joinerLeaverService.recordLeaver(mockGuildMember);

    expect(mockJoinerLeaverRepository.findOne).toHaveBeenCalledWith({ discordId: mockGuildMember.id });

    expect(joinerLeaverService['logger'].error).toHaveBeenCalledWith(`Attempted to record leaver ${mockGuildMember.user.tag} (${mockGuildMember.id}) but they were not found in the database.`);
  });

  it('should do nothing if the member is a bot', async () => {
    const mockMember = {
      user: { bot: true },
    } as GuildMember;

    await joinerLeaverService.recordLeaver(mockMember);

    expect(mockJoinerLeaverRepository.findOne).not.toHaveBeenCalled();
    expect(mockJoinerLeaverRepository.getEntityManager().persistAndFlush).not.toHaveBeenCalled();
    expect(joinerLeaverService['logger'].log).not.toHaveBeenCalled();
  });

  describe('startEnumeration', () => {
    const mockReport = `## Joiner & Leavers:
- üëã Joiners: **10**
- üö™ Leavers: **5**
- üëç Rejoiners: **2**
- ü•∫ Early Leavers: (<48h): **1**
- ‚è≥ Average Time to Leave: **1d 13h 37m**`;

    beforeEach(() => {
      mockJoinerLeaverStatisticsRepository.find = jest.fn().mockResolvedValue([mockJoinerLeaverStatisticsEntity]);
    });

    it('should produce the leaver report', async () => {
      await joinerLeaverService.startEnumeration(mockStatusMessage);

      expect(mockJoinerLeaverStatisticsRepository.find).toHaveBeenCalled();

      expect(mockStatusMessage.channel.send).toHaveBeenCalledWith(mockReport);
    });

    it('should handle error during enumeration', async () => {
      joinerLeaverService.enumerateJoinerLeavers = jest.fn().mockRejectedValue(new Error('Test error'));

      await joinerLeaverService.startEnumeration(mockStatusMessage);

      expect(mockJoinerLeaverStatisticsRepository.find).not.toHaveBeenCalled();
      expect(mockStatusMessage.channel.send).toHaveBeenCalledWith('Error enumerating joiner leaver records. Error: Test error');
    });

    it('should handle no statistics found', async () => {
      mockJoinerLeaverStatisticsRepository.find = jest.fn().mockResolvedValue([]);

      await joinerLeaverService.startEnumeration(mockStatusMessage);

      expect(mockJoinerLeaverStatisticsRepository.find).toHaveBeenCalled();
      expect(mockStatusMessage.channel.send).toHaveBeenCalledWith('No joiner leaver statistics found!');
    });
  });

  describe('enumerateJoinerLeavers', () => {
    let mockJoinerLeaveEntities: any[];

    beforeEach(() => {
      mockJoinerLeaveEntities = [
        // 2x current members
        { ...createMockJoinerLeaverEntity() },
        { ...createMockJoinerLeaverEntity() },
        // 1x leavers outside of the 48h window
        { ...createMockJoinerLeaverEntity(), joinDate: generateDateInPast(20), leaveDate: generateDateInPast(1) },
        // 2x early leavers
        { ...createMockJoinerLeaverEntity(), joinDate: generateDateInPast(4), leaveDate: generateDateInPast(3.9) },
        { ...createMockJoinerLeaverEntity(), joinDate: generateDateInPast(4), leaveDate: generateDateInPast(3.4) },
        // Rejoiner
        { ...createMockJoinerLeaverEntity(), joinDate: generateDateInPast(10), rejoinCount: 1 },
      ];

      mockJoinerLeaverRepository.findAll = jest.fn().mockResolvedValue(mockJoinerLeaveEntities);
    });

    it('should enumerate joiner leavers', async () => {
      await joinerLeaverService.enumerateJoinerLeavers();

      expect(mockJoinerLeaverRepository.findAll).toHaveBeenCalled();

      expect(mockJoinerLeaverStatisticsRepository.getEntityManager().persistAndFlush).toHaveBeenCalledWith({
        joiners: 6,
        leavers: 3,
        rejoiners: 1,
        earlyLeavers: 2,
        avgTimeToLeave: expect.any(String), // Tested elsewhere
        // Assumed / base entity autogenerated
        createdAt: expect.any(Date),
        updatedAt: expect.any(Date),
        id: undefined,
      });

      expect(joinerLeaverService['logger'].log).toHaveBeenCalledWith('Enumerated joiner leavers');
    });

    describe('calculateAverageTimeToLeave', () => {
      it('should calculate the average time to leave (5d)', () => {
        const simpleJoinerLeaveEntities = [
          {
            joinDate: generateDateInPast(5),
            leaveDate: generateDateInPast(0),
          } as JoinerLeaverEntity,
          {
            joinDate: generateDateInPast(10),
            leaveDate: generateDateInPast(5),
          } as JoinerLeaverEntity,
        ];

        const averageTime = joinerLeaverService.calculateAvgTimeToLeave(simpleJoinerLeaveEntities);

        expect(averageTime).toBe('5d 0h 0m');
      });

      it('should calculate the average time to leave (2.5d)', () => {
        const simpleJoinerLeaveEntities = [
          {
            joinDate: new Date('2025-01-01T00:00:00Z'),
            leaveDate: new Date('2025-01-03T13:00:00Z'),
          } as JoinerLeaverEntity,
          {
            joinDate: new Date('2025-01-01T00:00:00Z'),
            leaveDate: new Date('2025-01-03T11:00:00Z'),
          } as JoinerLeaverEntity,
        ];

        const averageTime = joinerLeaverService.calculateAvgTimeToLeave(simpleJoinerLeaveEntities);

        expect(averageTime).toBe('2d 12h 0m');
      });

      it('should calculate the average time to leave (2.5d)', () => {
        const simpleJoinerLeaveEntities = [
          {
            joinDate: new Date('2025-01-01T00:00:00Z'),
            leaveDate: new Date('2025-01-02T15:00:00Z'),
          } as JoinerLeaverEntity,
          {
            joinDate: new Date('2025-01-01T00:00:00Z'),
            leaveDate: new Date('2025-01-02T11:50:00Z'),
          } as JoinerLeaverEntity,
        ];

        const averageTime = joinerLeaverService.calculateAvgTimeToLeave(simpleJoinerLeaveEntities);

        expect(averageTime).toBe('1d 13h 25m');
      });

      it('should return "N/A" if there are no leavers', () => {
        const simpleJoinerLeaveEntities: JoinerLeaverEntity[] = [];

        const averageTime = joinerLeaverService.calculateAvgTimeToLeave(simpleJoinerLeaveEntities);

        expect(averageTime).toBe('N/A');
      });
    });
  });
});
